* jvo-asm [[https://travis-ci.org/jorenvo/jvo-asm][file:https://travis-ci.com/jorenvo/jvo-asm.svg?branch=master]]
This is a toy x86 assembler written from scratch. It was written to
gain a better understanding of how machine code and executable files
work. It's syntax uses a lot of emoji's because why not?
** Usage
#+BEGIN_EXAMPLE
$ cargo run -- examples/print.jas
abc
#+END_EXAMPLE

** Features
*** Constants
#+BEGIN_EXAMPLE
🖊LINUX_SYSCALL $128
# ...
❗ LINUX_SYSCALL
#+END_EXAMPLE

*** Comments
#+BEGIN_EXAMPLE
# I'm a comment
🦘= ✉exit
#+END_EXAMPLE

*** Addressing
**** Immediate addressing
#+BEGIN_EXAMPLE
⚫ ⬅ $8
#+END_EXAMPLE

Load 8 into ⚫.

**** Register addressing
#+BEGIN_EXAMPLE
🔴 ⬅ 🔵
#+END_EXAMPLE

Copies data from 🔵 into 🔴.

**** Direct addressing
#+BEGIN_EXAMPLE
📗my_number 3
# ...
🔴 ⬅ my_number
#+END_EXAMPLE

This loads 3 into 🔴.

**** Indirect addressing
#+BEGIN_EXAMPLE
🔴 ⬅ $0~🔵
#+END_EXAMPLE

This loads the value at the address contained in 🔵 into 🔴.

**** Base pointer addressing
#+BEGIN_EXAMPLE
🔴 ⬅ $4~🔵
#+END_EXAMPLE

Or alternatively with a constant:

#+BEGIN_EXAMPLE
🖊ST_ARG $8
# ...
🔴 ⬅ ST_ARG~🔵
#+END_EXAMPLE

This is similar to indirect addressing except that it adds a constant
offset to the address in 🔵.

*** Labels
#+BEGIN_EXAMPLE
🦘 ✉exit
# ...
📪exit:
⚪ ⬅ $1
❗ LINUX_SYSCALL
#+END_EXAMPLE

Labels are defined by prefixing them with 📪 and ending them with a
=:=. To refer to a label prefix it with ✉ instead.
*** Data sections
#+BEGIN_EXAMPLE
📗numbers 3, 67, 34, 222, 45
# ...
🔵 ⬅ numbers
#+END_EXAMPLE

Data sections start with 📗 and can be referred to later by just their
name.
*** ELF
jvo-asm builds a correct, =objdump= compatible ELF header.

*** Instruction reference
**** Registers
|----------+--------|
| *Symbol* | *Name* |
|----------+--------|
| ⚪       | =%eax= |
| 🔴       | =%ebx= |
| 🔵       | =%ecx= |
| ⚫       | =%edx= |
| ◀        | =%esp= |
| ⬇        | =%ebp= |
|----------+--------|

**** Instructions
|------------------+-----------+--------------------------|
| *Symbol*         | *Example* | *Description*            |
|------------------+-----------+--------------------------|
| ↩                | ↩         | Return from a function   |
| ➕               | ⚪ ➕ ⚫  | ~⚪ += ⚫~               |
| ➖               | ⚪ ➖ ⚫  | ~⚪ -= ⚫~               |
| ✖                | ⚪ ✖ ⚫   | ~⚪ *= ⚫~               |
| ⬅                | 🔴 ⬅ $1   | Move into register       |
| ❗               | ❗ $128   | Interrupt                |
| ⚖                | ⚖ ⚫, ⚪  | Compare ⚫ to ⚪         |
| 🦘=               | 🦘= ✉exit  | Jump if equal            |
| 🦘≠               | 🦘≠ ✉exit  | Jump if not equal        |
| 🦘<               | 🦘< ✉exit  | Jump if less than        |
| 🦘≤               | 🦘≤ ✉exit  | Jump if less or equal    |
| 🦘>               | 🦘> ✉exit  | Jump if greater than     |
| 🦘≥               | 🦘≥ ✉exit  | Jump if greater or equal |
| 🦘                | 🦘 ✉exit   | Unconditional jump       |
| 📞               | 📞 fn     | Call function            |
| 📥               | 📥 $8     | Push onto stack          |
| 📤               | 📤 🔵     | Pop from stack           |
| 🖊                |           |                          |
| 📪 (ends with :) |           |                          |
| 📗               |           |                          |
| ✉                |           |                          |
| $                |           |                          |
| 123              |           |                          |
| my_constant      |           |                          |
|------------------+-----------+--------------------------|
** Implementation notes
TODO: explain tokenize -> replace constants -> compile to intermediate -> compile intermediate -> create ELF
